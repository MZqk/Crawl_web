
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>操作系统学习笔记 - Sunnier - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=ChDk9h03-S75WEqNhGvXkWireJ5cCWdK1xRM9NIXfnM1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/SimpleBlue/bundle-SimpleBlue.css?v=jJERBFSojhmgst84aaRDal9S3q1WoO-WcNudmMzGJS81"/>
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="/skins/SimpleBlue/bundle-SimpleBlue-mobile.css?v=z0BacpCfWeLlXDCM0C158kTP_DMqMbGBapID4f-QztI1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/sunniest/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/sunniest/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/sunniest/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'sunniest', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=wUUQbLTt-LocHM-6RVSAUwAYdrfA1Lt3ool1ZdiICfI1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<div id="home">
<div id="header">
	<div id="blogTitle">
		
<!--done-->
<div class="title"><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/sunniest/">Sunnier</a></div>
<div class="subtitle"></div>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li id="nav_myhome"><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/sunniest/">首页</a></li>
<li id="nav_newpost"><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li id="nav_contact"><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Sunnier">联系</a></li>
<li id="nav_rss"><a id="blog_nav_rss" class="menu" href="http://www.cnblogs.com/sunniest/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="http://www.cnblogs.com/sunniest/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li id="nav_admin"><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔-50&nbsp;
文章-0&nbsp;
评论-226&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/sunniest/p/4215183.html">操作系统学习笔记</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px; color: #ff0000;">进程、线程概念</span></strong></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">进程</span>：一个进程就是一个正在执行的程序的实例。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px; color: #ff0000;">进程转换：</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">进程3个状态</span>：运行态，阻塞态，就绪态。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><img src="http://images.cnitblog.com/blog/694841/201501/101333096874556.png" alt="" /></span></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">1.进程为等待输入而阻塞。</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">2.调度程序选择另一个进程。</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">3.调度程序选择这个进程。</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">4.出现有效输入。</span></strong></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">线程</span>：轻量级进程。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">作业调度</span>：</span><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">按照某种原则，从后备作业队列中选取作业进入内存，并为作业做好运行前的准备工作以及作业完成后的善后处理工作。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">主要调度算法：</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">First Come First&nbsp;Serve （FCFS）先来先服务</span>：按到达时间先后排序。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">Shorted Job First (nonpreemptive &amp; preemptive ) 最短作业优先</span>：按作业的运行时间排序，由短到长。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">Round robin 轮转调度</span>：每个进程执行一个时间片后移到队列末尾，把CPU交给下一个进程。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">Priority Scheduling &nbsp;(nonpreemptive &amp; preemptive )&nbsp;优先级调度</span>：执行当前实时优先级最高的进程。动态优先级是在创建进程时赋予该进程一个初始优先级，然后其优先级随着进程的执行情况的变化而改变。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px; color: #ff0000;">Multiple Queues 多级队列：</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">1.进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">2.首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">3.对于同一个队列中的各个进程，按照时间片轮转法调度。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">4.在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。</span></p>
<p class="headline-2">&nbsp;</p>
<p class="headline-2"><span style="font-size: 15px; font-family: 'Microsoft YaHei'; color: #ff0000;">多级队列算法运作过程示例：</span></p>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。&nbsp;</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">现在有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。</span></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">1、时刻0 J1到达。于是进入到队列1 ， 运行1个时间片 ， 时间片还未到，此时J2到达。</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">2、时刻1 J2到达。 由于时间片仍然由J1掌控，于是等待。 J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。现在处理机分配给J2。&nbsp;</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">3、时刻2 J1进入Q2等待调度，J2获得CPU开始运行。&nbsp;</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">4、时刻3 J3到达，由于J2的时间片未到，故J3在Q1等待调度，J1也在Q2等待调度。&nbsp;</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">5、时刻4 J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">6、时刻5 J3经过1个时间片，完成。</span></strong></div>
<div class="para"><strong><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">7、时刻6 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。</span></strong></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">周转时间</span> 作业完成时刻减去作业到达的时刻：作业完成时刻-作业到达时刻</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">平均周转时间&nbsp;</span>用周转时间总时间除以作业个数：所有作业的周转时间/作业总数</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">甘特图&nbsp;</span>一种作业执行情况描述图，如下SJF（最短作业调度）。</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><img src="http://images.cnitblog.com/blog/694841/201501/101631072654929.png" alt="" /></span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></div>
<div class="para"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></div>
<p><span style="font-size: 15px; line-height: 22px; font-family: 'Microsoft YaHei';">用户空间建立的线程包和内核建立的线程包区别图</span></p>
<p><span style="font-size: 15px; line-height: 22px; font-family: 'Microsoft YaHei';"><img src="http://images.cnitblog.com/blog/694841/201501/101507016402896.jpg" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">临界区<span style="color: #000000;">：</span></span>每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">信号量</span>：在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px; color: #ff0000;">信号量有两种操作：down,up，也就是所谓的P,V操作</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">down</span>:如果信号量大于0，则继续，等于0则进程将睡眠，将信号量减1。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><span style="color: #ff0000;">up</span>:将信号量加1，如果信号量大于0，则继续，若小于或等于0，则唤醒一阻塞在该信号量上的进程。</span></p>
<p class="p15">&nbsp;</p>
<p class="p15"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">例如：Semaphore的初值为n,&nbsp;m个进程使用该semaphore访问关键区，那么semaphore值的变化范围是多少？</span></p>
<p class="p15"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">每个进程进入关键区时都会使Semaphore减1，离开时又使Semaphore加1，所以范围是n-m到n。</span></p>
<p class="p15"><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 15px; line-height: 22px;">信号量可以用来解决一些进程同步的问题，例如：</span></span></p>
<p class="p15">&nbsp;</p>
<p class="p15"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">用P、V操作说明互斥量，定出司机与售票员之间的同步算法，司机与售票员活动如下图所示。</span></p>
<p class="p15">&nbsp;</p>
<p class="p15"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;"><img src="http://images.cnitblog.com/blog/694841/201501/111208006876498.png" alt="" /></span></p>
<p class="p15"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">在汽车行驶过程中，司机活动与售票员活动之间的同步关系为：售票员关车门后向司机发开车信号，司机接到开车信号后启动车辆，在汽车正常行驶过程中售票员售票，到站时司机停车，售票员在车停后开车门让乘客下车。因此司机启动车辆的动作必须与售票员关车门的动作取得同步；售票员开车门的动作也必须与司机停车取得同步。</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">所以在本题中，应设置两个信号量s1、s2，s1表示是否允许司机启动汽车，其初值为0；s2表示是否允许售票员开车门，其初值为0。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">所以解答为：（可以将P操作看成是wait--等待信号，V操作看成是signal--发出信号）</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">Semaphore&nbsp;&nbsp;s1,s2=0; &nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">Driver() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Saler()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p(s1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关车门；</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动车辆；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　v(s1);</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常行车；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　售票；</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到站停车；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　p(s2);</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(s2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开车门；&nbsp;</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　上下乘客；</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 15px; line-height: 22px;">几个利用信号量和线程解决的IPC（进程间通信）经典问题：</span></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 15px; line-height: 22px;">1.生产者与消费者问题</span></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 15px; line-height: 22px;">在同一个进程地址空间内执行的两个线程生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。当生产者线程生产物品时，如果没有空缓冲区可用，那么生产者线程必须等待消费者线程释放出一个空缓冲区。当消费者线程消费物品时，如果没有满的缓冲区，那么消费者线程将被阻塞，直到新的物品被生产出来。</span></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 15px; line-height: 22px;">C解决此问题的源码：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">#define</span> N 100  <span style="color: #008000;">//</span><span style="color: #008000;">缓冲区的槽数目</span>
<span style="color: #008080;"> 2</span> typedef <span style="color: #0000ff;">int</span><span style="color: #000000;"> semaphore;  
</span><span style="color: #008080;"> 3</span> semaphore mutex = <span style="color: #800080;">1</span> ;  <span style="color: #008000;">//</span><span style="color: #008000;">临界区（缓冲区）信号量，以互斥各线程的进入</span>
<span style="color: #008080;"> 4</span> semaphore empty = N;   <span style="color: #008000;">//</span><span style="color: #008000;">缓冲区的空槽数目</span>
<span style="color: #008080;"> 5</span> semaphore full = <span style="color: #800080;">0</span>;   <span style="color: #008000;">//</span><span style="color: #008000;">缓冲区的满槽数目</span>
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">void</span> producer(<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> 　　<span style="color: #0000ff;">int</span><span style="color: #000000;"> item;
</span><span style="color: #008080;"> 9</span> 　　<span style="color: #0000ff;">while</span><span style="color: #000000;"> (TRUE) {
</span><span style="color: #008080;">10</span> 　　　　item =<span style="color: #000000;"> produce_item( );
</span><span style="color: #008080;">11</span> 　　　　down( &amp;empty);   <span style="color: #008000;">//</span><span style="color: #008000;">空槽减1</span>
<span style="color: #008080;">12</span> 　　　　down( &amp;mutex);  <span style="color: #008000;">//</span><span style="color: #008000;">进入临界区</span>
<span style="color: #008080;">13</span> 　　　　inserUtem(item);  <span style="color: #008000;">//</span><span style="color: #008000;">加入数据</span>
<span style="color: #008080;">14</span> 　　　　up( &amp;mutex);  <span style="color: #008000;">//</span><span style="color: #008000;">离开临界区</span>
<span style="color: #008080;">15</span> 　　　　up( &amp;full); <span style="color: #008000;">//</span><span style="color: #008000;">满槽加1</span>
<span style="color: #008080;">16</span> <span style="color: #000000;">       }
</span><span style="color: #008080;">17</span> <span style="color: #000000;">}
</span><span style="color: #008080;">18</span> <span style="color: #0000ff;">void</span> consumer(<span style="color: #0000ff;">void</span><span style="color: #000000;">)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span> 　　<span style="color: #0000ff;">int</span><span style="color: #000000;"> item;
</span><span style="color: #008080;">21</span> 　　<span style="color: #0000ff;">while</span><span style="color: #000000;"> (TRUE) {
</span><span style="color: #008080;">22</span> 　　　　down( &amp;<span style="color: #000000;">full);
</span><span style="color: #008080;">23</span> 　　　　down( &amp;<span style="color: #000000;">mutex);
</span><span style="color: #008080;">24</span> 　　　　item =<span style="color: #000000;"> remove_ item( );
</span><span style="color: #008080;">25</span> 　　　　up( &amp;<span style="color: #000000;">mutex);
</span><span style="color: #008080;">26</span> 　　　　up( &amp;<span style="color: #000000;">empty);
</span><span style="color: #008080;">27</span> 　　consume_item(item);  <span style="color: #008000;">//</span><span style="color: #008000;">消费一个数据项</span>
<span style="color: #008080;">28</span> 　　<span style="color: #000000;">}
</span><span style="color: #008080;">29</span> }</pre>
</div>
<p>&nbsp;</p>
<p>2.哲学家就餐问题</p>
<p>假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</p>
<p><img src="http://images.cnitblog.com/blog/694841/201501/111340427506389.jpg" alt="" /></p>
<p>C解决此问题源码：</p>
<p><img src="http://images.cnitblog.com/blog/694841/201501/111341321561597.jpg" alt="" /></p>
<p><img src="http://images.cnitblog.com/blog/694841/201501/111341418284973.jpg" alt="" /></p>
<p>PS：philosopher函数未完整，应该修改为下图：</p>
<p><img src="http://images.cnitblog.com/blog/694841/201501/111356367504136.jpg" alt="" width="239" height="217" /></p>
<p>值得注意的是，philosopher函数会有不同的5个进程来调，参数为 0 到 N-1 。</p>
<p>&nbsp;</p>
<p>3.读者写者的问题</p>
<p>有一个被许多进程共享的数据区，这个数据区可以是一个文件，或者主存的一块空间，甚至可以是一组处理器寄存器。有一些只读取这个数据区的进程（<span lang="EN-US" xml:lang="EN-US">reader）和一些只往数据区中写数据的进程（<span lang="EN-US" xml:lang="EN-US">writer）。以下假设共享数据区是文件。这些读者和写者对数据区的操作必须满足以下条件：读<span lang="EN-US" xml:lang="EN-US">&mdash;读允许；读<span lang="EN-US" xml:lang="EN-US">&mdash;写互斥；写<span lang="EN-US" xml:lang="EN-US">&mdash;写互斥。这些条件具体来说就是：</span></span></span></span></span></p>
<p>（<span lang="EN-US" xml:lang="EN-US">1）任意多的读进程可以同时读这个文件；</span></p>
<p>（<span lang="EN-US" xml:lang="EN-US">2）一次只允许一个写进程往文件中写；</span></p>
<p>（<span lang="EN-US" xml:lang="EN-US">3）如果一个写进程正在往文件中写，禁止任何读进程或写进程访问文件；</span></p>
<p align="left">（<span lang="EN-US" xml:lang="EN-US">4）写进程执行写操作前，应让已有的写者或读者全部退出。这说明当有读者在读文件时不允许写者写文件。</span></p>
<p align="left">C语言解决此问题源码：写者优先算法</p>
<p align="left"><img src="http://images.cnitblog.com/blog/694841/201501/111420427969161.png" alt="" width="581" height="509" /></p>
<p align="left">&nbsp;</p>
<p align="left">死锁</p>
<p align="left">资源死锁的4个条件：</p>
<div>1）互斥条件：在一段时间内某资源只由一个进程占用，如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</div>
<div>2）占有和等待条件：已经得到了某个资源的进程可以再请求新的资源。</div>
<div>3）不可抢占条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</div>
<div>4）环路等待条件：指在发生死锁时，必然存在一个进程&mdash;&mdash;资源的环形链，即进程集合{P0，P1，P2，&middot;&middot;&middot;，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，&hellip;&hellip;，Pn正在等待已被P0占用的资源。</div>
<div>&nbsp;</div>
<div>不发生死锁的判断：</div>
<div>m个资源，n个进程，每个进程最大需求w。</div>
<div>满足 (w-1)*n+1&lt;m 则不会发生死锁。</div>
<div>&nbsp;</div>
<div>避免死锁的方法：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。</div>
<div>&nbsp;</div>
<div>银行家算法：。一种避免死锁的算法。</div>
<div>银行家算法基本思想：分配资源之前，判断系统是否是安全的；若是，才分配。</div>
<div>安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使每一个进程运行完毕。</div>
<div>例如：</div>
<div>
<p class="p0">现在有<span style="font-family: Calibri;">5</span><span style="font-family: 宋体;">个进程</span><span style="font-family: Calibri;">A</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">B</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">C</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">E</span><span style="font-family: 宋体;">，有</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">种类型的资源</span><span style="font-family: Calibri;">R1</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R2</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R3</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R4</span><span style="font-family: 宋体;">。在</span><span style="font-family: Calibri;">T0</span><span style="font-family: 宋体;">时刻系统状态如下。</span><span style="font-family: Calibri;">R1</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R2</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R3</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">R4</span><span style="font-family: 宋体;">的剩余资源数依次为</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">0</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">3</span><span style="font-family: 宋体;">。</span></p>
<p class="p0">回答下面问题：</p>
<p class="p0">（<span style="font-family: Calibri;">1</span><span style="font-family: 宋体;">）</span><span style="font-family: Calibri;">T0</span><span style="font-family: 宋体;">时刻是否为安全状态？</span></p>
<p class="p0">（<span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">）若这时</span><span style="font-family: Calibri;">D</span><span style="font-family: 宋体;">提出申请（</span><span style="font-family: Calibri;">1,2,0,3</span><span style="font-family: 宋体;">），是否能实施资源分配？</span></p>
<p class="p0"><span style="font-family: 宋体;"><img src="http://images.cnitblog.com/blog/694841/201501/111713072342612.png" alt="" /></span></p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/111715482183663.png" alt="" /></p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/111717179377953.png" alt="" /></p>
<p class="p0">&nbsp;</p>
<p class="p0">虚地址到实地址的翻译过程</p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/111803465789106.png" alt="" /></p>
<p class="p0">几种主要的页面置换算法：</p>
<p class="p0">FIFO(First In First Out)先进先出：按照先进先出顺序淘汰页面。（ps:页面替换时，出现重复页面，此页面的顺序按照之前的页面顺序算）</p>
<p class="p0">LRU( Least Recently Used&nbsp;) 最近最少使用：将前一段时间内没使用的页面置换。</p>
<p class="p0">OPT( Optimal )最佳页面置换算法：</p>
<div class="para">1、如果页框中的某个页面P以后永不使用，则该页面为淘汰页面Pt。</div>
<div class="para">2、如果每个P都会再次被访问，那么其中最长未来时间内不再被访问的页面为淘汰页面Pt。</div>
<div class="para">（ps:此算法不可能实现，因为当缺页中断发生时，操作系统接下来页面的访问顺序。）</div>
</div>
<div>&nbsp;</div>
<div>例如：</div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/111938162188933.png" alt="" /></div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/111938495626681.png" alt="" /></div>
<div>其实LRU在置换某页面时就是向前看，距离这个置换页面最远的页面被置换。</div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/111938275935225.png" alt="" /></div>
<div>FIFO就是按照最先放入的页面或者说顺序在前的页面置换掉。</div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/111938593901245.gif" alt="" /></div>
<div>OPT只需要看置换页面位置后面的页面，按照出现顺序，不出现或者最晚出现的被置换掉。如果都没出现就任意置换，一般置换第一个。</div>
<div>&nbsp;</div>
<div>
<p class="p0">磁盘调度算法</p>
<p class="p0">FCFS (First Come First Served) 先来先服务：和进程调度一样。</p>
<p class="p0">最短寻道优先算法（Shortest Seek First）：以磁头位置寻找下一个距离最近的磁道。</p>
<p class="p0">SCAN（扫描<span style="font-family: 宋体;">算法 又称 电梯算法）：第一个磁道选择离磁头最近的磁道，然后按照磁头移动方向依次选择最近磁道，当此方向上磁道都选择完毕时，反向选择最近磁道。</span></p>
<p class="p0"><span style="font-family: 宋体;">例如：</span></p>
<p class="p0"><span style="font-family: 宋体;"><img src="http://images.cnitblog.com/blog/694841/201501/112304597346624.png" alt="" /></span></p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/112305078593975.png" alt="" /></p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/112305165154997.png" alt="" /></p>
<p class="p0"><img src="http://images.cnitblog.com/blog/694841/201501/112305247035861.png" alt="" /></p>
<p class="p0">&nbsp;</p>
<p class="p0">Inode</p>
<div>文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。</div>
<div>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。</div>
<div>文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。</div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/131658289333748.png" alt="" /></div>
<div>Directory</div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/131711191512876.png" alt="" /></div>
<div>记录了一个文件/目录名称对应的Inode number。</div>
<div>PS：</div>
<div>1.目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</div>
<div>2.每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</div>
<div>3.Unix/Linux系统允许多个文件名指向同一个inode号码。</div>
<div>&nbsp;</div>
<div>HardLink 硬链接</div>
<div>可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。</div>
<div>&nbsp;</div>
<div>SoftLink 软链接</div>
<div>
<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接"（symbolic link）。</p>
<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。</p>
</div>
<div>&nbsp;</div>
</div>
<div>
<div>Block devices &amp; Character devices&nbsp;块设备&amp;字符设备</div>
<div>I/O设备大致分为两类：块设备和字符设备。块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能独立于其它块而读写。磁盘是最常见的块设备。</div>
</div>
<div>&nbsp;</div>
<div><span class="lemmaTitleH1">FAT&nbsp;(File Allocation Table&nbsp;文件配置表)</span></div>
<div>
<p>一个分区分成同等大小的簇，也就是连续空间的小块。簇的大小随着FAT文件系统的类型以及分区大小而不同，典型的簇大小介于2KB到32KB之间。每个文件根据它的大小可能占有一个或者多个簇；这样，一个文件就由这些这些（称为单链表）簇链所表示。然而，这些链并不一定一个接着一个在磁盘上存储，它们经常是在整个数据区域零散的储存。&nbsp;<br />文件分配表（FAT）是映射到分区每个簇的条目列表。每个条目记录下面五种信息中的一种：&nbsp;<br />1.链中下一个簇的地址&nbsp;&nbsp;<br />2.一个特殊的文件结束符（EOF）</p>
<p>3.符号指示链的结束&nbsp;&nbsp;&nbsp;</p>
<p>4.一个特殊的符号标示坏簇&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>5.一个特殊的符号标示保留簇 (&nbsp;0来表示空闲簇 )</p>
<p>&nbsp;</p>
<p>Memory mapped I/O : 就是把磁盘上的file映射到内存上，当我们从内存上fetch byte时，对应的file就被读取。同样的，当我们在内存上存储字节的时候，对应的file就被写入。这就让我们不需通过read和write系统调用而去操作I/O。</p>
<p>&nbsp;</p>



</div>
<div>设备独立性：<span style="line-height: 1.5;">指</span><span style="line-height: 1.5;">操作系统</span><span style="line-height: 1.5;">把所有</span><span style="line-height: 1.5;">外部设备</span><span style="line-height: 1.5;">统一当作成文件来看待，只要安装它们的</span><span style="line-height: 1.5;">驱动程序</span><span style="line-height: 1.5;">，任何用户都可以像使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。</span></div>
<div>&nbsp;</div>
<div>三种I/O实现方式：</div>
<div><span style="line-height: 1.5;">1.Programmed I/O （程序控制I/O）是指用特定的IO指令实现从设备到CPU的数据传输，CPU需要做全部操作。</span></div>
<div>
<div>&nbsp;</div>
<div>2.DMA （Direct Memory Access&nbsp;<span class="lemmaTitleH1">直接存储器访问）</span></div>
<div><span class="lemmaTitleH1">DMA传输将数据从一个地址空间复制到另外一个地址空间。CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工作。</span></div>
<div>&nbsp;</div>
<div><span class="lemmaTitleH1">3.Interrupt-Driven I/O （ 中断驱动I/O ）：当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务，设备控制器则按照该命令的要求去控制指定I/O设备。此时，CPU与I/O设备并行操作。</span></div>



</div>
<div>&nbsp;</div>
<div>Disk Formatting&nbsp;( 磁盘格式化 )</div>
<div>磁盘格式化是在物理驱动器（磁盘）的所有数据区上写零的操作过程，格式化是一种纯物理操作，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。</div>
<div>&nbsp;</div>
<div>Domain（保护域/域）:一对（对象、权限）组合。</div>
<div>&nbsp;<img src="http://images.cnitblog.com/blog/694841/201501/141224067141364.jpg" alt="" width="837" height="405" /></div>
<div><img src="http://images.cnitblog.com/blog/694841/201501/141224304646774.jpg" alt="" width="948" height="748" /></div>
<div>每个文件可以在不同的域中有不同的权限，每个域也能切换到其他域，此时文件的权限改变，例如UNIX的进程有2个部分，用户部分和核心部分，当执行系统调用时，进程从用户部分切换到核心部分，核心部分可以访问与用户部分不同的对象集。</div>
<div>&nbsp;</div>
<div>ACL（Access Control List）访问控制链表</div>
<div>&nbsp;</div>
<div>&nbsp;</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2015-01-10 16:33</span> <a href='http://www.cnblogs.com/sunniest/'>Sunnier</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=4215183" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4215183);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=205616,cb_entryId=4215183,cb_blogApp=currentBlogApp,cb_blogUserGuid='43282244-7c70-e411-b908-9dcfd8948a71',cb_entryCreatedDate='2015/1/10 16:33:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<div id='cnblogs_c2' class='c_ad_block'></div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2017 Sunnier
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
</body>
</html>
